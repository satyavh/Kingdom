# namespace function from the coffeescript faq
namespace = (target, name, block) ->
  [target, name, block] = [(if typeof exports isnt 'undefined' then exports else window), arguments...] if arguments.length < 3
  top    = target
  target = target[item] or= {} for item in name.split '.'
  block target, top


class Stable
  constructor: (@name) ->

    # find the castle for the stables
    @castle = $('[data-bind="array: ' + @name + '"]') 

    # this is the template that will be repeated
    @stable = @castle.find('[data-bind="template: ' + @name + '"]').detach()     

  clear: ->
    # clear the castle of stables
    @castle.empty()

  addStable: (index) ->
    el = @stable.clone().appendTo(@castle).show()
    el.attr 'data-index', index
    el.attr 'data-model', @name
    return el


class @Castle

  # lookAlike are Castle templates generated by an array
  stables: []  

  # keep a virtual dom, only consisting of binding elements
  dom: []

  # possible bindings
  bindings: ["disabled", "text", "src", "if", "unless", "array", "href", "id", "value", "height", "width"]

  # possible events
  events: ["click", "hover", "mouseover", "mouseleave"]

  constructor: (inauguration) ->

    # every castle needs a name
    @name = inauguration.name

    # deploy the properties of this castle
    if inauguration.properties?
      for key, value of inauguration.properties
        @processData key, value

    # deploy functions of this castle
    if inauguration.functions?
      for key, value of inauguration.functions
        @[key] = value    

    # install soldiers in the castle
    if inauguration.soldiers?    
      for key, value of inauguration.soldiers
        @soldier @name + '.' + key, value

    # set a data model, if any
    if inauguration.model?
      @model = model

    # save a reference to the castle, in case it gets destroyed
    @castle = $('[data-template=' + @name + ']')

    # call an init function
    if inauguration.construct?
      @['construct'] = inauguration.construct
      @construct()

    @render()  

  # make this Castle go stealth
  hide: =>
    @castle.hide()

  # show only this Castle
  uberCastle: =>
    $('.template').hide()
    @castle.show()  

  # find a condition on a property, support subkeys
  findPropertyValue: (condition) =>

    c = condition.split('.')
    property = c[0]

    return unless @[property]?

    if c.length > 1
      key = c.slice(1).join('.')
      value = @[property][key]
    else
      value = @[property] 
    
    return value   


  # evaluate a single if
  evaluateIf: (condition) =>
    el = $('[data-bind="if: ' + condition + '"]')

    if @findPropertyValue(condition) is true
      el.css
        display: 'inline'
      el.parent().find('> [data-bind="else"]').hide()
    else
      el.hide()
      el.parent().find('> [data-bind="else"]').css display: 'inline'

  # evaluate  a singleunless
  evaluateUnless: (condition) =>
    el = $('[data-bind="unless: ' + condition + '"]')

    unless @findPropertyValue(condition) is true  
      el.css
        display: 'inline'
      el.parent().find('> [data-bind="else"]').hide()            
    else
      el.hide()            
      el.parent().find('> [data-bind="else"]').css display: 'inline'

  # evaluate all unless in the DOM
  evaluateUnlesses: (condition) =>
    $('[data-bind*="unless: "]').each (i, el) =>

      [binding, condition] = $(el).data('bind').split(': ')    

      @evaluateUnless condition

  # evaluate all ifs in the DOM
  evaluateIfs: (condition) =>
    $('[data-bind*="if: "]').each (i, el) =>

      [binding, condition] = $(el).data('bind').split(': ')    

      @evaluateIf condition

  # render Stables (child templates) based on an array input
  renderStables: (stableName) =>

    # support models with . - lets not do this for now
    # sn = stableName.split '.'
    # if sn.length > 0
    #   model = Kingdom.unflatten sn[0]
    # else
    #   model = @[stableName]

    return unless @[stableName]?

    # check if this Stable already exists, if yes, use that one
    stable =_.filter @stables, (s) -> 
      s.name is stableName

    if stable.length > 0
      stable = stable[0]
      stable.clear()      
    else
      stable = new Stable stableName
      @stables.push stable

    # console.log 'render stable', @[stableName].length, stableName

    # append templates
    for item, i in @get(stableName)
      el = stable.addStable i

      @applyBindings el


  # apply a single binding to an elemen
  applyBinding: (el, binding, value) =>

    if value?
      # check and process mustache bindings in value, or otherwise process value
      mustache = new RegExp "({{)([a-z.]*)(}})", "ig"    

      if mustache.test(value)
        value = value.replace mustache, (_, start, val, end) =>
          val = @_parseValue el, val
          val = @findPropertyValue val        
      else
        value = @_parseValue el, value


    # console.log binding, value, @events.indexOf(binding) > -1

    # custom bindings
    if _.indexOf(@bindings, binding) > -1
      switch binding
        when "disabled"
          if $(el).is 'input', 'button'
            $(el).prop binding, @findPropertyValue(value)
          else
            $(el).attr binding, @findPropertyValue(value)
        when "text"
          $(el).text @findPropertyValue(value)
        when "src", "id"
          # if there's a value found, bind that, otherwise bind the string 
          if @findPropertyValue(value)?
            $(el).attr binding, @findPropertyValue(value) 
          else
            $(el).attr binding, value
        when "if"
          @evaluateIf value
        when "unless"
          @evaluateUnless value
        when "value"
          #apply a 2-way binding
          $(el).val(@findPropertyValue(value))
          $(el).keyup (e) =>
            console.log e.target.value
            @set @[value], e.target.value
        when "array"
          @renderStables value
        when "background-image"
          $(el).css
            'background-image': 'url("' + @findPropertyValue(value) + '")'
        when "height", "width"
          $(el).css
            binding: @findPropertyValue(value)

    # event bindings
    if _.indexOf(@events, binding) > -1
      # console.log   $(el).attr('disabled')? or $(el).prop('disabled')?

      $(el).on binding, (e) =>
        e.preventDefault() 
        e.stopPropagation()         
        @[value](el)        
      
    # assume everything else is just an attribute binding
    if _.indexOf(@bindings, binding) is -1 and _.indexOf(@events, binding) is -1
      if value?
        $(el).attr 'data-' + binding, @findPropertyValue(value)

  _parseValue: (el, value) ->
    if value?
      v = value.split('.')

      # check if there's reference to a model
      # then find that model on the closest template
      if v[0] is 'model'
        parent = $(el).closest('.template')
        model = parent.data('model')
        index = parent.data('index')
        console.log model, index
        value = model + '.' + index + '.' + v[1]   

    value   

  # process and apply all template bindings
  applyBindings: (template) =>
    
    $(template).find('[data-bind]').each (i, el) =>

      # split multiple bindings
      bindings = $(el).data('bind').replace(/\s/g, '').split(',')

      # and apply them
      for binding in bindings
        [b, value] = binding.split(':')

        # push binding to virtual dom
        @addToDom el, b, value
        @applyBinding el, b, value


  addToDom: (el, b, v) ->
    # add binding sto virtual dom
    @dom.push
      el: el
      binding: b
      value: v

  # render and show this castle
  render: =>
    $(document).ready =>
      @castle.show()    
      @applyBindings @castle

  # detach this castle
  detach: =>
    @castle = @castle.detach()

  # append this castle somewhere
  append: (el) =>
    el.append @castle

  # destroy this castle
  destroy: =>
    @castle.empty()
    delete @

  # deploy or change a soldier
  set: (key, value) =>
    @processData key, value

    # let everyone in the castle know this soldier changed
    @order key, value

    return unless @dom

    # find & reapply binding
    bindings = _.filter @dom, (e) ->
      e.value is key

    return unless bindings.length > 0

    for bind in bindings
      @applyBinding bind.el, bind.binding, bind.value

  # summon a soldier
  get: (key) =>
    # return flattened objects unflattened
    if _.isObject @[key]
      return Kingdom.unflatten @[key]

    @[key]

  # using https://github.com/cowboy/jquery-tiny-pubsub for pub-sub here
  jquery = $({})  

  # toggle a boolean property
  toggleProperty: (key) =>
    value = @get key
    return unless typeof value is 'boolean'
    @set key, !value

  orders: {}

  soldier: (order, soldier) ->    
    # console.log order, soldier

    # create the order if not yet created
    if !@orders[order]
      @orders[order] = []

    # add the soldier
    @orders[order].push soldier

    # console.log 'soldiers', @orders

    
  order: (order, data, namespace = true) ->
    if namespace
      order = @name + '.' + order

    # console.log 'order', order

    # return if the order doesn't exist, or there are no soldiers
    return if !@orders[order] or @orders[order].length < 1

    # send the event to all soldiers
    _.each @orders[order], (soldier) =>
      soldier.apply @, [data] or []
      return


  # fire a soldier, meaning he will be eliminated
  dischargeSoldier: (soldier) ->
    # console.log @orders
    @orders[soldier]

  processData: (key, value) ->
    # attaches key, value to Castle. Flattens objects, transforms arrays with objects to arrays with flattened objects

    if _.isObject value
      # if _.isArray value
      #   @[key] = []

      #   for item in value
      #     if _.isObject item
      #       @[key].push Kingdom.flatten item
      #     else
      #       @[key].push item

      # else
      
      # make an exception for empty arrays
      if value.length is 0
        @[key] = []
      else
        @[key] = Kingdom.flatten value
    else
      @[key] = value    

  renderMustaches: (template) ->
    template = $(template)

    mustache = new RegExp "({{)([a-z .]*)(}})", "g"

    # replace mustache by date
    template



@Kingdom = 

  create: (name) ->

    namespace name, (exports) ->
      exports.Castle = Castle
      exports.Stable = Stable

  # flattens an object
  # using http://jsfiddle.net/WSzec/14/, it's supposed to be the fastest way to flatten, unflatten data
  flatten: (data) ->
    result = {}

    recurse = (cur, prop) ->
      if Object(cur) != cur
        result[prop] = cur
      else if _.isArray(cur)
        i = 0
        l = cur.length
        while i < l
          recurse cur[i], if prop then prop + '.' + i else '' + i
          i++
        if l == 0
          result[prop] = []
      else
        isEmpty = true
        for p of cur
          isEmpty = false
          recurse cur[p], if prop then prop + '.' + p else p
        if isEmpty
          result[prop] = {}
      return

    recurse data, ''
    result  

  unflatten: (data) ->
    'use strict'
    if Object(data) != data or _.isArray(data)
      return data
    result = {}
    cur = undefined
    prop = undefined
    idx = undefined
    last = undefined
    temp = undefined
    for p of data
      cur = result
      prop = ''
      last = 0
      loop
        idx = p.indexOf('.', last)
        temp = p.substring(last, if idx != -1 then idx else undefined)
        cur = cur[prop] or (cur[prop] = if !isNaN(parseInt(temp)) then [] else {})
        prop = temp
        last = idx + 1
        unless idx >= 0
          break
      cur[prop] = data[p]
    result['']   