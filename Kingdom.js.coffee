# namespace function from the coffeescript faq
namespace = (target, name, block) ->
  [target, name, block] = [(if typeof exports isnt 'undefined' then exports else window), arguments...] if arguments.length < 3
  top    = target
  target = target[item] or= {} for item in name.split '.'
  block target, top


class _Stable
  constructor: (@name) ->

    # find the castle for the stables
    @castle = $('[data-bind="array: ' + @name + '"]') 

    # this is the template that will be repeated
    @stable = @castle.find('[data-bind="template: ' + @name + '"]').detach()     

  _clear: ->
    # clears the castle of stables
    @castle.empty()

  _addStable: (index) ->
    # adds a subtemplate to the castle

    el = @stable.clone().appendTo(@castle).show()
    el.attr 'data-index', index
    el.attr 'data-model', @name
    return el


class @Castle

  # lookAlike are Castle templates generated by an array
  stables: []  

  # keep a virtual dom, only consisting of binding elements
  dom: []

  # possible bindings
  bindings: ["disabled", "text", "src", "if", "unless", "array", "href", "id", "value", "height", "width"]

  # possible events
  events: ["click", "hover", "mouseover", "mouseleave"]

  constructor: (inauguration) ->

    # every castle needs a name
    @name = inauguration.name

    # deploy the properties of this castle
    if inauguration.properties?
      for key, value of inauguration.properties
        @_processData key, value

    # deploy functions of this castle
    if inauguration.functions?
      for key, value of inauguration.functions
        @[key] = value    

    # install soldiers in the castle
    if inauguration.soldiers?    
      for key, value of inauguration.soldiers
        @soldier @name + '.' + key, value

    # set a data model, if any
    if inauguration.model?
      @model = model

    # save a reference to the castle, in case it gets destroyed
    @castle = $('[data-template=' + @name + ']')

    # call an init function
    if inauguration.construct?
      @['construct'] = inauguration.construct
      @construct()

    @_render()  

  # make this Castle go stealth
  hide: =>
    @castle.hide()

  # show only this Castle
  uberCastle: =>
    $('.template').hide()
    @castle.show()  

  # find a condition on a property, supports subkeys
  _findPropertyValue: (condition) =>

    c = condition.split('.')
    property = c[0]

    return unless @[property]?

    if c.length > 1
      key = c.slice(1).join('.')
      value = @[property][key]
    else
      value = @[property] 
    
    return value   


  # evaluate a single if
  _evaluateIf: (condition) =>
    el = $('[data-bind="if: ' + condition + '"]')

    if @_findPropertyValue(condition) is true
      el.css
        display: 'inline'
      el.parent().find('> [data-bind="else"]').hide()
    else
      el.hide()
      el.parent().find('> [data-bind="else"]').css display: 'inline'

  # evaluate  a singleunless
  _evaluateUnless: (condition) =>
    el = $('[data-bind="unless: ' + condition + '"]')

    unless @_findPropertyValue(condition) is true  
      el.css
        display: 'inline'
      el.parent().find('> [data-bind="else"]').hide()            
    else
      el.hide()            
      el.parent().find('> [data-bind="else"]').css display: 'inline'

  # evaluate all unless in the DOM
  _evaluateUnlesses: (condition) =>
    $('[data-bind*="unless: "]').each (i, el) =>

      [binding, condition] = $(el).data('bind').split(': ')    

      @_evaluateUnless condition

  # evaluate all ifs in the DOM
  _evaluateIfs: (condition) =>
    $('[data-bind*="if: "]').each (i, el) =>

      [binding, condition] = $(el).data('bind').split(': ')    

      @_evaluateIf condition

  # _render Stables (child templates) based on an array input
  _renderStables: (stableName) =>

    return unless @[stableName]?

    # check if this Stable already exists, if yes, use that one
    stable =_.filter @stables, (s) -> 
      s.name is stableName

    if stable.length > 0
      stable = stable[0]
      stable._clear()      
    else
      stable = new _Stable stableName
      @stables.push stable

    # append subtemplates
    for item, i in @get(stableName)
      el = stable._addStable i

      @_applyBindings el


  # apply a single binding to an elemen
  _applyBinding: (el, binding, value) =>

    if value?
      # check and process mustache bindings in value, or otherwise process value
      mustache = new RegExp "({{)([a-z.]*)(}})", "ig"    

      if mustache.test(value)
        value = value.replace mustache, (_, start, val, end) =>
          val = @_parseValue el, val
          val = @_findPropertyValue val        
      else
        value = @_parseValue el, value

    # supported bindings
    if _.indexOf(@bindings, binding) > -1
      switch binding
        when "disabled"
          if $(el).is 'input', 'button'
            $(el).prop binding, @_findPropertyValue(value)
          else
            $(el).attr binding, @_findPropertyValue(value)
        when "text"
          $(el).text @_findPropertyValue(value)
        when "src", "id"
          # if there's a value found, bind that, otherwise bind the string 
          if @_findPropertyValue(value)?
            $(el).attr binding, @_findPropertyValue(value) 
          else
            $(el).attr binding, value
        when "if"
          @_evaluateIf value
        when "unless"
          @_evaluateUnless value
        when "value"
          #apply a 2-way binding
          $(el).val(@_findPropertyValue(value))
          $(el).keyup (e) =>
            @set @[value], e.target.value
        when "array"
          @_renderStables value
        when "background-image"
          $(el).css
            'background-image': 'url("' + @_findPropertyValue(value) + '")'
        when "height", "width"
          $(el).css
            binding: @_findPropertyValue(value)

    # supported event bindings
    if _.indexOf(@events, binding) > -1
      $(el).on binding, (e) =>
        e.preventDefault() 
        e.stopPropagation()         
        @[value](el)        
      
    # assume everything else is just an attribute binding
    if _.indexOf(@bindings, binding) is -1 and _.indexOf(@events, binding) is -1
      if value?
        $(el).attr 'data-' + binding, @_findPropertyValue(value)

  _parseValue: (el, value) ->
    if value?
      v = value.split('.')

      # check if there's reference to a model
      # then find that model on the closest template
      if v[0] is 'model'
        parent = $(el).closest('.template')
        model = parent.data('model')
        index = parent.data('index')
        value = model + '.' + index + '.' + v[1]   

    value   


  # process and apply all template bindings
  _applyBindings: (template) =>
    
    $(template).find('[data-bind]').each (i, el) =>

      # split multiple bindings
      bindings = $(el).data('bind').replace(/\s/g, '').split(',')

      # and apply them
      for binding in bindings
        [b, value] = binding.split(':')

        # push binding to virtual dom
        @_addToDom el, b, value
        @_applyBinding el, b, value



  _addToDom: (el, b, v) ->
    # add bindings to virtual dom
    @dom.push
      el: el
      binding: b
      value: v


  # render and show this castle
  _render: =>
    $(document).ready =>
      @castle.show()    
      @_applyBindings @castle


  # detach this castle
  detach: =>
    @castle = @castle.detach()


  # append this castle somewhere
  append: (el) =>
    el.append @castle


  # destroy this castle
  destroy: =>
    @castle.empty()
    delete @


  # deploy or change a soldier
  set: (key, value) =>
    @_processData key, value

    # let everyone in the castle know this soldier changed
    @order key, value

    return unless @dom

    # find & reapply binding
    bindings = _.filter @dom, (e) ->
      e.value is key

    return unless bindings.length > 0

    for bind in bindings
      @_applyBinding bind.el, bind.binding, bind.value


  # summon a soldier
  get: (key) =>
    # return _flattened objects _unflattened
    if _.isObject @[key]
      return Kingdom._unflatten @[key]

    @[key]

  # using https://github.com/cowboy/jquery-tiny-pubsub for pub-sub here
  jquery = $({})  


  # toggle a boolean property
  toggleProperty: (key) =>
    value = @get key
    return unless typeof value is 'boolean'
    @set key, !value

  orders: {}


  soldier: (order, soldier) ->    
    # create the order if not yet created
    if !@orders[order]
      @orders[order] = []

    # add the soldier
    @orders[order].push soldier
    

  order: (soldier, data, namespace = true) ->
    # by default orders are namespaced to the castle
    if namespace
      soldier = @name + '.' + soldier

    # return if the order doesn't exist, or there are no soldiers
    return if !@orders[soldier] or @orders[soldier].length < 1

    # send the event to all soldiers
    _.each @orders[soldier], (o) =>
      o.apply @, [data] or []
      return


  # fire a soldier, meaning he will be eliminated
  dischargeSoldier: (soldier) ->
    @orders[soldier].pop soldier


  _processData: (key, value) ->
    # attaches key, value to Castle. _flattens objects, transforms arrays with objects to arrays with _flattened objects

    if _.isObject value
      # if _.isArray value
      #   @[key] = []

      #   for item in value
      #     if _.isObject item
      #       @[key].push Kingdom._flatten item
      #     else
      #       @[key].push item

      # else
      
      # make an exception for empty arrays
      if value.length is 0
        @[key] = []
      else
        @[key] = Kingdom._flatten value
    else
      @[key] = value    

  _renderMustaches: (template) ->
    template = $(template)

    mustache = new RegExp "({{)([a-z .]*)(}})", "g"

    # replace mustache by date
    template



@Kingdom = 

  create: (name) ->

    namespace name, (exports) ->
      exports.Castle = Castle
      exports.Stable = Stable

  # _flattens an object
  # using http://jsfiddle.net/WSzec/14/, it's supposed to be the fastest way to _flatten, _unflatten data
  _flatten: (data) ->
    result = {}

    recurse = (cur, prop) ->
      if Object(cur) != cur
        result[prop] = cur
      else if _.isArray(cur)
        i = 0
        l = cur.length
        while i < l
          recurse cur[i], if prop then prop + '.' + i else '' + i
          i++
        if l == 0
          result[prop] = []
      else
        isEmpty = true
        for p of cur
          isEmpty = false
          recurse cur[p], if prop then prop + '.' + p else p
        if isEmpty
          result[prop] = {}
      return

    recurse data, ''
    result  

  _unflatten: (data) ->
    'use strict'
    if Object(data) != data or _.isArray(data)
      return data
    result = {}
    cur = undefined
    prop = undefined
    idx = undefined
    last = undefined
    temp = undefined
    for p of data
      cur = result
      prop = ''
      last = 0
      loop
        idx = p.indexOf('.', last)
        temp = p.substring(last, if idx != -1 then idx else undefined)
        cur = cur[prop] or (cur[prop] = if !isNaN(parseInt(temp)) then [] else {})
        prop = temp
        last = idx + 1
        unless idx >= 0
          break
      cur[prop] = data[p]
    result['']   